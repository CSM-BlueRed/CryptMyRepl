import os
from shutil import rmtree
from sys import argv
import random
from base64 import b64encode
from zlib import compress
os.system('')


def encrypt(stream: bytes) -> tuple[bytes, bytes]:
    key = bytes(random.choices(range(255 + 1), k = len(stream)))
    return bytes(kc ^ sc for kc, sc in zip(key, stream)), key


ansi_esc = u'\u001b'
rgb = lambda r, g, b: f'{ansi_esc}[38;2;%s;%s;%sm' % (r, g, b)
reset = f'{ansi_esc}[0m'

red = rgb(255, 75, 75)
blue = rgb(75, 75, 255)
green = rgb(0, 255, 0)


comments = '''
This repl is now private, and the source is not visible.
Any user that want to see files of the repl will be blocked by the cryption

║ The key is private and if you dont, you need to add repl environ
╚═> with the key in key.txt of your files generated by CryptMyRepl

you can delete these comments and CryptMyRepl generated files has no license!

║ CryptMyRepl
║ by BlueRed
║ - https://github.com/CSM-BlueRed/CryptMyRepl
╚═>
'''[1:-1]


if __name__ == '__main__':
    if len(argv) < 2:
        print(f'{red}you need to specify a file in the first command argv{reset}')
        raise SystemExit

    file = argv[1]

    if not os.path.isfile(file):
        print(f'{red}the file {green}{file}{red} doesnt exist{reset}')
        raise SystemExit

    if os.path.isdir('repl'):
        rmtree('repl')

    elif os.path.isfile('repl'):
        os.remove('repl')

    os.mkdir('repl')

    crypted, key = encrypt(open(file, 'rb').read())
    readable_key = b64encode(compress(key)).decode()

    crypt_my_repl_class = r'''
class CryptMyRepl:
    key = key
    stream = stream
'''[1:-1]

    script = [
        '\n'.join(f'# {comment}' for comment in comments.splitlines()) + '\n',
        r'''import os, base64, zlib''',
        r'''key: bytes = zlib.decompress(base64.b64decode(os.getenv('CRYPTIONKEY').encode()))''',
        r'''stream: bytes = zlib.decompress({!r})'''.format(compress(crypted)) + '\n',
        crypt_my_repl_class,
        r'''exec(bytes(kc ^ sc for kc, sc in zip(key, stream)), {'CryptMyReplClass': CryptMyRepl})'''
    ]

    script = '\n'.join(script)
    final = './repl/main.py'
    final = os.path.abspath(final)

    with open(final, 'w', encoding = 'utf-8') as f:
        f.write(script)

    final = os.path.normpath(final)
    for item in ('\\:.'):
        final = final.replace(item, f'{reset}{item}{green}')

    key_path = './repl/key.txt'

    with open(key_path, 'w', encoding = 'utf-8') as f:
        f.write(readable_key)

    for item in ('./'):
        key_path = key_path.replace(item, f'{reset}{item}{green}')

    print(f'finished! Your private script is located in {green}{final}{reset}!')
    print(f'now, create tour repl, and add a env key {green}CRYPTIONKEY{reset}, copy the key in {green}{key_path}{reset} and paste it as the value')